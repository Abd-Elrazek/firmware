/******************************************************************* 
 * C file generated by Protoc for Embedded C.                      *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : spark.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/
 
#include "spark.pb.h"

int _memcmp(const void *p1, const void *p2, unsigned int size) {
    unsigned int i;
    for(i = 0; i < size; ++ i) {
        if(*((char*)p1 + i) > *((char*)p2 + i))
            return 1;
        if(*((char*)p1 + i) < *((char*)p2 + i))
            return -1;
    }
    return 0;
} 
 
void _memset(void *msg_ptr, char init_val, unsigned int size) {
    unsigned int i;
    for(i = 0; i < size; ++ i)
        *((char*)msg_ptr + i) = init_val;
}

int varint_packed_size(unsigned long value) {
    if ((value & (0xffffffff <<  7)) == 0) return 1;
    if ((value & (0xffffffff << 14)) == 0) return 2;
    if ((value & (0xffffffff << 21)) == 0) return 3;
    if ((value & (0xffffffff << 28)) == 0) return 4;
    return 5;  
}

int write_raw_byte(char value, void *_buffer, int offset) {
    *((char *)_buffer + offset) = value;
    return ++offset;
}

/** Write a little-endian 32-bit integer. */
int write_raw_little_endian32(unsigned long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
    
    return offset;
}

/** Write a little-endian 64-bit integer. */
int write_raw_little_endian64(unsigned long long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 32) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 40) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 48) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value >> 56) & 0xFF), _buffer, offset);
    
    return offset;
}

int write_raw_varint32(unsigned long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7F) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value >> 7;
        }
    }
    return offset;
}

int write_raw_varint64(unsigned long long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7FL) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value >> 7;
        }
    }
    return offset;
}

int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset) {
    int i; 
    for(i = 0; i < bytes_size; ++ i) {
        offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
    }
    
    return offset;   
}

unsigned long encode_zig_zag32(signed long n) {
    /* Note:  the right-shift must be arithmetic. */
    return (n << 1) ^ (n >> 31);
}

unsigned long long encode_zig_zag64(signed long long n) {
    /* Note:  the right-shift must be arithmetic. */
    return (n << 1) ^ (n >> 63);
} 

signed long decode_zig_zag32(unsigned long n) {
    return (n >> 1) ^ -(n & 1);
}

signed long long decode_zig_zag64(unsigned long long n) {
    return (n >> 1) ^ -(n & 1);
}

int read_raw_byte(char *tag, void *_buffer, int offset) {
    *tag = *((char *) _buffer + offset);
    
    return ++offset;
}

/** Read a 32-bit little-endian integer from the stream. */
int read_raw_little_endian32(unsigned long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    
    *tag = (((unsigned long)b1 & 0xff)      ) |
           (((unsigned long)b2 & 0xff) <<  8) |
           (((unsigned long)b3 & 0xff) << 16) |
           (((unsigned long)b4 & 0xff) << 24);
           
    return offset;
}

/** Read a 64-bit little-endian integer from the stream. */
int read_raw_little_endian64(unsigned long long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b5 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b6 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b7 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b8 = (char) *tag;
    
    *tag = (((unsigned long long)b1 & 0xff)      ) |
           (((unsigned long long)b2 & 0xff) <<  8) |
           (((unsigned long long)b3 & 0xff) << 16) |
           (((unsigned long long)b4 & 0xff) << 24) |
           (((unsigned long long)b5 & 0xff) << 32) |
           (((unsigned long long)b6 & 0xff) << 40) |
           (((unsigned long long)b7 & 0xff) << 48) |
           (((unsigned long long)b8 & 0xff) << 56);
           
    return offset;
}

int read_raw_varint32(unsigned long *tag, void *_buffer, int offset) {
    signed char result;
    
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag = result;
        return offset;
    }
    *tag = result & 0x7f;
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag |= result << 7;
    } else {
        *tag |= (result & 0x7f) << 7;
        offset = read_raw_byte((char *)&result, _buffer, offset);
        if (result >= 0) {
            *tag |= result << 14;
        } else {
            *tag |= (result & 0x7f) << 14;
            offset = read_raw_byte((char *)&result, _buffer, offset);
            if (result >= 0) {
                *tag |= ((unsigned long)result) << 21;
            } else {
                *tag |= (((unsigned long)result) & 0x7f) << 21;
                offset = read_raw_byte((char *)&result, _buffer, offset);
                *tag |= ((unsigned long)result) << 28;
                if (result < 0) {
                    /* Discard upper 32 bits. */
                    int i;
                    for (i = 0; i < 5; ++ i) {
                        offset = read_raw_byte((char *)&result, _buffer, offset);
                        if (result >= 0) {
                            return offset;
                        }
                    }
                    /* Invalid state. */
                }
            }
        }
    }
    return offset;
}

int read_raw_varint64(unsigned long long *tag, void *_buffer, int offset) {
    short shift = 0;
    signed char b;
    *tag = 0;
    while (shift < 64) {
        offset = read_raw_byte((char *)&b, _buffer, offset);
        *tag |= (unsigned long long)(b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            return offset;
        }
        shift += 7;
    }
    /* return error code. */
    return -1;
}

int can_read_raw_varint32(void *_buffer, int offset, int length) {
    signed char c;
    
    /* Bound length to valid range [0..5]. */
    if (length < 0) length = 0; else
    if (length > 5) length = 5;
    
    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; /* Can read (1 == true). */
        }
        length--;
    }
    
    return 0; /* Cannot read (0 == false). */
}

int can_read_raw_varint64(void *_buffer, int offset, int length) {
    signed char c;
    
    /* Bound length to valid range [0..5]. */
    if (length < 0) length = 0; else
    if (length > 10) length = 10;
    
    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; /* Can read (1 == true). */
        }
        length--;
    }
    
    return 0; /* Cannot read (0 == false). */
}

int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length) {
    unsigned long size;
    int payload_offset;

    if (length <= 0) return 0; /* Cannot read from empty or invalid message. */

    if (!can_read_raw_varint32(_buffer, offset, length)) {
        return 0; /* Could not even read the preceding size as varint32. */
    }

    payload_offset = read_raw_varint32(&size, _buffer, offset);
    length = length - (payload_offset - offset);

    return (length >= size) ? 1 : 0;
}

unsigned long Message_get_delimited_size(void *_buffer, int offset) {
    unsigned long size = 0;
    int old_offset = offset;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    
    return size + offset - old_offset;
}

/*******************************************************************
* Enumeration: Spark.proto, line 75
*******************************************************************/
int Type_write_with_tag(enum Type *_Type, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_Type, _buffer, offset);
    
    return offset;
}

/*******************************************************************
* Enumeration: Spark.proto, line 7
*******************************************************************/
int DataType_write_with_tag(enum DataType *_DataType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_DataType, _buffer, offset);
    
    return offset;
}


/*******************************************************************
 * Message: Spark.proto, line 15
 *******************************************************************/

void DataValue_clear(struct DataValue *_DataValue) {
	_memset(_DataValue, 0, sizeof(struct DataValue));
}

void DataValue_init_optional_attributes(struct DataValue *_DataValue) {
	_DataValue->_type = 0;
	
	_DataValue->_vString_len = 0;
	
	
	_DataValue->_vInt = 0;
	
	_DataValue->_vDouble = 0.0;
	
	_DataValue->_vBool = 0;
	
	_DataValue->_vBytes_len = 0;
	
	
}

int DataValue_is_default_message(struct DataValue *_DataValue) {
    return _DataValue->_type == 0
    
     && _DataValue->_vString_len == 0
    
     && _DataValue->_vInt == 0
    
     && _DataValue->_vDouble == 0.0
    
     && _DataValue->_vBool == 0
    
     && _DataValue->_vBytes_len == 0
    ;
}

int DataValue_write(struct DataValue *_DataValue, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_type != 0) {
	    offset = DataType_write_with_tag(&_DataValue->_type, _buffer, offset, 1);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_vString_len != 1
	    || _DataValue->_vString[0] != '0') {
		offset = write_raw_varint32((2<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_DataValue->_vString_len, _buffer, offset);
	    offset = write_raw_bytes(_DataValue->_vString, _DataValue->_vString_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_vInt != 0) {
		offset = write_raw_varint32((3<<3)+0, _buffer, offset);
	    if (_DataValue->_vInt >= 0)
	        offset = write_raw_varint32(_DataValue->_vInt, _buffer, offset);
	    else
	        offset = write_raw_varint64(_DataValue->_vInt, _buffer, offset);	    
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_vDouble != 0) {
		offset = write_raw_varint32((4<<3)+1, _buffer, offset);
	    unsigned long long*vDouble_ptr = (unsigned long long*)&_DataValue->_vDouble;
	    offset = write_raw_little_endian64(*vDouble_ptr, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_vBool != 0) {
		offset = write_raw_varint32((5<<3)+0, _buffer, offset);
	    offset = write_raw_byte(_DataValue->_vBool, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_DataValue->_vBytes_len != 1
	    || _DataValue->_vBytes[0] != '0') {
		offset = write_raw_varint32((6<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_DataValue->_vBytes_len, _buffer, offset);
	    offset = write_raw_bytes(_DataValue->_vBytes, _DataValue->_vBytes_len, _buffer, offset);
	}
	
	return offset;
}

int DataValue_write_with_tag(struct DataValue *_DataValue, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = DataValue_write_delimited_to(_DataValue, _buffer, offset);
	
	return offset;
}

int DataValue_write_delimited_to(struct DataValue *_DataValue, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = DataValue_write(_DataValue, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int DataValue_read(void *_buffer, struct DataValue *_DataValue, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	DataValue_clear(_DataValue);
	/* Assign the optional attributes. */
	DataValue_init_optional_attributes(_DataValue);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _DataValue._type */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_DataValue->_type = tag;
	        	break;
	        /* tag of: _DataValue._vString */
	        case 2 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_DataValue->_vString_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_DataValue->_vString + i), _buffer, offset);
	        	break;
	        /* tag of: _DataValue._vInt */
	        case 3 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_DataValue->_vInt = (signed long)tag;
	        	break;
	        /* tag of: _DataValue._vDouble */
	        case 4 :
	        	offset = read_raw_little_endian64(&value, _buffer, offset);
	        	double *vDouble = (double *)(&value);
	        	_DataValue->_vDouble = *vDouble;
	        	break;
	        /* tag of: _DataValue._vBool */
	        case 5 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_DataValue->_vBool = tag & 1;
	        	break;
	        /* tag of: _DataValue._vBytes */
	        case 6 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_DataValue->_vBytes_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_DataValue->_vBytes + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int DataValue_read_delimited_from(void *_buffer, struct DataValue *_DataValue, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	DataValue_read(_buffer, _DataValue, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 24
 *******************************************************************/

void Chunk_clear(struct Chunk *_Chunk) {
	_memset(_Chunk, 0, sizeof(struct Chunk));
}

void Chunk_init_optional_attributes(struct Chunk *_Chunk) {
	_Chunk->_crc_len = 0;
	
	
	_Chunk->_length = 0;
	
	_Chunk->_data_len = 0;
	
	
}

int Chunk_is_default_message(struct Chunk *_Chunk) {
    return _Chunk->_crc_len == 0
    
     && _Chunk->_length == 0
    
     && _Chunk->_data_len == 0
    ;
}

int Chunk_write(struct Chunk *_Chunk, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_Chunk->_crc_len != 1
	    || _Chunk->_crc[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_Chunk->_crc_len, _buffer, offset);
	    offset = write_raw_bytes(_Chunk->_crc, _Chunk->_crc_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_Chunk->_length != 0) {
		offset = write_raw_varint32((2<<3)+0, _buffer, offset);
	    offset = write_raw_varint32(_Chunk->_length, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_Chunk->_data_len != 1
	    || _Chunk->_data[0] != '0') {
		offset = write_raw_varint32((3<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_Chunk->_data_len, _buffer, offset);
	    offset = write_raw_bytes(_Chunk->_data, _Chunk->_data_len, _buffer, offset);
	}
	
	return offset;
}

int Chunk_write_with_tag(struct Chunk *_Chunk, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = Chunk_write_delimited_to(_Chunk, _buffer, offset);
	
	return offset;
}

int Chunk_write_delimited_to(struct Chunk *_Chunk, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = Chunk_write(_Chunk, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int Chunk_read(void *_buffer, struct Chunk *_Chunk, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	Chunk_clear(_Chunk);
	/* Assign the optional attributes. */
	Chunk_init_optional_attributes(_Chunk);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _Chunk._crc */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Chunk->_crc_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_Chunk->_crc + i), _buffer, offset);
	        	break;
	        /* tag of: _Chunk._length */
	        case 2 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Chunk->_length = tag;
	        	break;
	        /* tag of: _Chunk._data */
	        case 3 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Chunk->_data_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_Chunk->_data + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int Chunk_read_delimited_from(void *_buffer, struct Chunk *_Chunk, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	Chunk_read(_buffer, _Chunk, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 30
 *******************************************************************/

void ChunkReceived_clear(struct ChunkReceived *_ChunkReceived) {
	_memset(_ChunkReceived, 0, sizeof(struct ChunkReceived));
}

void ChunkReceived_init_optional_attributes(struct ChunkReceived *_ChunkReceived) {
	_ChunkReceived->_crc_len = 0;
	
	
}

int ChunkReceived_is_default_message(struct ChunkReceived *_ChunkReceived) {
    return _ChunkReceived->_crc_len == 0
    ;
}

int ChunkReceived_write(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_ChunkReceived->_crc_len != 1
	    || _ChunkReceived->_crc[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_ChunkReceived->_crc_len, _buffer, offset);
	    offset = write_raw_bytes(_ChunkReceived->_crc, _ChunkReceived->_crc_len, _buffer, offset);
	}
	
	return offset;
}

int ChunkReceived_write_with_tag(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = ChunkReceived_write_delimited_to(_ChunkReceived, _buffer, offset);
	
	return offset;
}

int ChunkReceived_write_delimited_to(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = ChunkReceived_write(_ChunkReceived, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int ChunkReceived_read(void *_buffer, struct ChunkReceived *_ChunkReceived, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	ChunkReceived_clear(_ChunkReceived);
	/* Assign the optional attributes. */
	ChunkReceived_init_optional_attributes(_ChunkReceived);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _ChunkReceived._crc */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_ChunkReceived->_crc_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_ChunkReceived->_crc + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int ChunkReceived_read_delimited_from(void *_buffer, struct ChunkReceived *_ChunkReceived, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	ChunkReceived_read(_buffer, _ChunkReceived, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 34
 *******************************************************************/

void Event_clear(struct Event *_Event) {
	_memset(_Event, 0, sizeof(struct Event));
}

void Event_init_optional_attributes(struct Event *_Event) {
	_Event->_name_len = 0;
	
	
	_Event->_data_len = 0;
	
	
}

int Event_is_default_message(struct Event *_Event) {
    return _Event->_name_len == 0
    
     && _Event->_data_len == 0
    ;
}

int Event_write(struct Event *_Event, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_Event->_name_len != 1
	    || _Event->_name[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_Event->_name_len, _buffer, offset);
	    offset = write_raw_bytes(_Event->_name, _Event->_name_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_Event->_data_len != 1
	    || _Event->_data[0] != '0') {
		offset = write_raw_varint32((2<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_Event->_data_len, _buffer, offset);
	    offset = write_raw_bytes(_Event->_data, _Event->_data_len, _buffer, offset);
	}
	
	return offset;
}

int Event_write_with_tag(struct Event *_Event, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = Event_write_delimited_to(_Event, _buffer, offset);
	
	return offset;
}

int Event_write_delimited_to(struct Event *_Event, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = Event_write(_Event, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int Event_read(void *_buffer, struct Event *_Event, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	Event_clear(_Event);
	/* Assign the optional attributes. */
	Event_init_optional_attributes(_Event);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _Event._name */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Event->_name_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_Event->_name + i), _buffer, offset);
	        	break;
	        /* tag of: _Event._data */
	        case 2 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Event->_data_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_Event->_data + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int Event_read_delimited_from(void *_buffer, struct Event *_Event, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	Event_read(_buffer, _Event, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 39
 *******************************************************************/

void Ignored_clear(struct Ignored *_Ignored) {
	_memset(_Ignored, 0, sizeof(struct Ignored));
}

void Ignored_init_optional_attributes(struct Ignored *_Ignored) {
	_Ignored->_received = 0;
	
}

int Ignored_is_default_message(struct Ignored *_Ignored) {
    return _Ignored->_received == 0
    ;
}

int Ignored_write(struct Ignored *_Ignored, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_Ignored->_received != 0) {
		offset = write_raw_varint32((1<<3)+0, _buffer, offset);
	    offset = write_raw_varint32(_Ignored->_received, _buffer, offset);
	}
	
	return offset;
}

int Ignored_write_with_tag(struct Ignored *_Ignored, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = Ignored_write_delimited_to(_Ignored, _buffer, offset);
	
	return offset;
}

int Ignored_write_delimited_to(struct Ignored *_Ignored, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = Ignored_write(_Ignored, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int Ignored_read(void *_buffer, struct Ignored *_Ignored, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	Ignored_clear(_Ignored);
	/* Assign the optional attributes. */
	Ignored_init_optional_attributes(_Ignored);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _Ignored._received */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Ignored->_received = tag;
	        	break;
	    }
	}
	
	return offset;
}

int Ignored_read_delimited_from(void *_buffer, struct Ignored *_Ignored, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	Ignored_read(_buffer, _Ignored, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 43
 *******************************************************************/

void KeyChange_clear(struct KeyChange *_KeyChange) {
	_memset(_KeyChange, 0, sizeof(struct KeyChange));
}

void KeyChange_init_optional_attributes(struct KeyChange *_KeyChange) {
	_KeyChange->_ciphertext1_len = 0;
	
	
	_KeyChange->_ciphertext2_len = 0;
	
	
	_KeyChange->_ciphertext3_len = 0;
	
	
	_KeyChange->_signature1_len = 0;
	
	
	_KeyChange->_signature2_len = 0;
	
	
	_KeyChange->_signature3_len = 0;
	
	
}

int KeyChange_is_default_message(struct KeyChange *_KeyChange) {
    return _KeyChange->_ciphertext1_len == 0
    
     && _KeyChange->_ciphertext2_len == 0
    
     && _KeyChange->_ciphertext3_len == 0
    
     && _KeyChange->_signature1_len == 0
    
     && _KeyChange->_signature2_len == 0
    
     && _KeyChange->_signature3_len == 0
    ;
}

int KeyChange_write(struct KeyChange *_KeyChange, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_ciphertext1_len != 1
	    || _KeyChange->_ciphertext1[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_ciphertext1_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_ciphertext1, _KeyChange->_ciphertext1_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_ciphertext2_len != 1
	    || _KeyChange->_ciphertext2[0] != '0') {
		offset = write_raw_varint32((2<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_ciphertext2_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_ciphertext2, _KeyChange->_ciphertext2_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_ciphertext3_len != 1
	    || _KeyChange->_ciphertext3[0] != '0') {
		offset = write_raw_varint32((3<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_ciphertext3_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_ciphertext3, _KeyChange->_ciphertext3_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_signature1_len != 1
	    || _KeyChange->_signature1[0] != '0') {
		offset = write_raw_varint32((4<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_signature1_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_signature1, _KeyChange->_signature1_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_signature2_len != 1
	    || _KeyChange->_signature2[0] != '0') {
		offset = write_raw_varint32((5<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_signature2_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_signature2, _KeyChange->_signature2_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_signature3_len != 1
	    || _KeyChange->_signature3[0] != '0') {
		offset = write_raw_varint32((6<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_signature3_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_signature3, _KeyChange->_signature3_len, _buffer, offset);
	}
	
	return offset;
}

int KeyChange_write_with_tag(struct KeyChange *_KeyChange, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = KeyChange_write_delimited_to(_KeyChange, _buffer, offset);
	
	return offset;
}

int KeyChange_write_delimited_to(struct KeyChange *_KeyChange, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = KeyChange_write(_KeyChange, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int KeyChange_read(void *_buffer, struct KeyChange *_KeyChange, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	KeyChange_clear(_KeyChange);
	/* Assign the optional attributes. */
	KeyChange_init_optional_attributes(_KeyChange);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _KeyChange._ciphertext1 */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_ciphertext1_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_ciphertext1 + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._ciphertext2 */
	        case 2 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_ciphertext2_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_ciphertext2 + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._ciphertext3 */
	        case 3 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_ciphertext3_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_ciphertext3 + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._signature1 */
	        case 4 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_signature1_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_signature1 + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._signature2 */
	        case 5 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_signature2_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_signature2 + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._signature3 */
	        case 6 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_signature3_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_signature3 + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int KeyChange_read_delimited_from(void *_buffer, struct KeyChange *_KeyChange, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	KeyChange_read(_buffer, _KeyChange, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 53
 *******************************************************************/

void VariableRequest_clear(struct VariableRequest *_VariableRequest) {
	_memset(_VariableRequest, 0, sizeof(struct VariableRequest));
}

void VariableRequest_init_optional_attributes(struct VariableRequest *_VariableRequest) {
	_VariableRequest->_name_len = 0;
	
	
	_VariableRequest->_set = 0;
	
}

int VariableRequest_is_default_message(struct VariableRequest *_VariableRequest) {
    return _VariableRequest->_name_len == 0
    
     && _VariableRequest->_set == 0;

     /* Ignore DataValue */
}

int VariableRequest_write(struct VariableRequest *_VariableRequest, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_VariableRequest->_name_len != 1
	    || _VariableRequest->_name[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_VariableRequest->_name_len, _buffer, offset);
	    offset = write_raw_bytes(_VariableRequest->_name, _VariableRequest->_name_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_VariableRequest->_set != 0) {
		offset = write_raw_varint32((2<<3)+0, _buffer, offset);
	    offset = write_raw_byte(_VariableRequest->_set, _buffer, offset);
	}
	
	int value_cnt;
	for (value_cnt = 0; value_cnt < _VariableRequest->_value_repeated_len; ++ value_cnt) {
	    offset = DataValue_write_with_tag(&_VariableRequest->_value[value_cnt], _buffer, offset, 3);
	}
	
	return offset;
}

int VariableRequest_write_with_tag(struct VariableRequest *_VariableRequest, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = VariableRequest_write_delimited_to(_VariableRequest, _buffer, offset);
	
	return offset;
}

int VariableRequest_write_delimited_to(struct VariableRequest *_VariableRequest, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = VariableRequest_write(_VariableRequest, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int VariableRequest_read(void *_buffer, struct VariableRequest *_VariableRequest, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	VariableRequest_clear(_VariableRequest);
	/* Assign the optional attributes. */
	VariableRequest_init_optional_attributes(_VariableRequest);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _VariableRequest._name */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_VariableRequest->_name_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_VariableRequest->_name + i), _buffer, offset);
	        	break;
	        /* tag of: _VariableRequest._set */
	        case 2 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_VariableRequest->_set = tag & 1;
	        	break;
	        /* tag of: _VariableRequest._value */
	        case 3 :
	        	offset = DataValue_read_delimited_from(_buffer, &_VariableRequest->_value[(int)_VariableRequest->_value_repeated_len++], offset);
	        	break;
	    }
	}
	
	return offset;
}

int VariableRequest_read_delimited_from(void *_buffer, struct VariableRequest *_VariableRequest, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	VariableRequest_read(_buffer, _VariableRequest, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 59
 *******************************************************************/

void VariableValue_clear(struct VariableValue *_VariableValue) {
	_memset(_VariableValue, 0, sizeof(struct VariableValue));
}

void VariableValue_init_optional_attributes(struct VariableValue *_VariableValue) {
	_VariableValue->_name_len = 0;
	
	
}

int VariableValue_is_default_message(struct VariableValue *_VariableValue) {
    return _VariableValue->_name_len == 0;
    
    /* Ignore DataValue */
}

int VariableValue_write(struct VariableValue *_VariableValue, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_VariableValue->_name_len != 1
	    || _VariableValue->_name[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_VariableValue->_name_len, _buffer, offset);
	    offset = write_raw_bytes(_VariableValue->_name, _VariableValue->_name_len, _buffer, offset);
	}
	
	int value_cnt;
	for (value_cnt = 0; value_cnt < _VariableValue->_value_repeated_len; ++ value_cnt) {
	    offset = DataValue_write_with_tag(&_VariableValue->_value[value_cnt], _buffer, offset, 2);
	}
	
	return offset;
}

int VariableValue_write_with_tag(struct VariableValue *_VariableValue, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = VariableValue_write_delimited_to(_VariableValue, _buffer, offset);
	
	return offset;
}

int VariableValue_write_delimited_to(struct VariableValue *_VariableValue, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = VariableValue_write(_VariableValue, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int VariableValue_read(void *_buffer, struct VariableValue *_VariableValue, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	VariableValue_clear(_VariableValue);
	/* Assign the optional attributes. */
	VariableValue_init_optional_attributes(_VariableValue);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _VariableValue._name */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_VariableValue->_name_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_VariableValue->_name + i), _buffer, offset);
	        	break;
	        /* tag of: _VariableValue._value */
	        case 2 :
	        	offset = DataValue_read_delimited_from(_buffer, &_VariableValue->_value[(int)_VariableValue->_value_repeated_len++], offset);
	        	break;
	    }
	}
	
	return offset;
}

int VariableValue_read_delimited_from(void *_buffer, struct VariableValue *_VariableValue, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	VariableValue_read(_buffer, _VariableValue, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 64
 *******************************************************************/

void FunctionCall_clear(struct FunctionCall *_FunctionCall) {
	_memset(_FunctionCall, 0, sizeof(struct FunctionCall));
}

void FunctionCall_init_optional_attributes(struct FunctionCall *_FunctionCall) {
	_FunctionCall->_name_len = 0;
	
	
}

int FunctionCall_is_default_message(struct FunctionCall *_FunctionCall) {
    return _FunctionCall->_name_len == 0;
    
    /* Ignore DataValue */
}

int FunctionCall_write(struct FunctionCall *_FunctionCall, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_FunctionCall->_name_len != 1
	    || _FunctionCall->_name[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_FunctionCall->_name_len, _buffer, offset);
	    offset = write_raw_bytes(_FunctionCall->_name, _FunctionCall->_name_len, _buffer, offset);
	}
	
	int argNames_cnt;
	for (argNames_cnt = 0; argNames_cnt < _FunctionCall->_argNames_repeated_len; ++ argNames_cnt) {
	    offset = write_raw_varint32((2<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_FunctionCall->_argNames_len[argNames_cnt], _buffer, offset);
	    offset = write_raw_bytes(_FunctionCall->_argNames[argNames_cnt], _FunctionCall->_argNames_len[argNames_cnt], _buffer, offset);
	}
	
	int value_cnt;
	for (value_cnt = 0; value_cnt < _FunctionCall->_value_repeated_len; ++ value_cnt) {
	    offset = DataValue_write_with_tag(&_FunctionCall->_value[value_cnt], _buffer, offset, 3);
	}
	
	return offset;
}

int FunctionCall_write_with_tag(struct FunctionCall *_FunctionCall, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = FunctionCall_write_delimited_to(_FunctionCall, _buffer, offset);
	
	return offset;
}

int FunctionCall_write_delimited_to(struct FunctionCall *_FunctionCall, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = FunctionCall_write(_FunctionCall, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int FunctionCall_read(void *_buffer, struct FunctionCall *_FunctionCall, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	FunctionCall_clear(_FunctionCall);
	/* Assign the optional attributes. */
	FunctionCall_init_optional_attributes(_FunctionCall);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _FunctionCall._name */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_FunctionCall->_name_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_FunctionCall->_name + i), _buffer, offset);
	        	break;
	        /* tag of: _FunctionCall._argNames */
	        case 2 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        		/* Set length of current string. */
	        	_FunctionCall->_argNames_len[(int)_FunctionCall->_argNames_repeated_len] = tag;
	        	/* Copy raw bytes of current string. */
	        	for(i = 0; i < tag; ++ i) {
	        	    offset = read_raw_byte(&_FunctionCall->_argNames[(int)_FunctionCall->_argNames_repeated_len][i], _buffer, offset);
	        	}
	        	/* Advance to next string. */
	        	_FunctionCall->_argNames_repeated_len++; 
	        	break;
	        /* tag of: _FunctionCall._value */
	        case 3 :
	        	offset = DataValue_read_delimited_from(_buffer, &_FunctionCall->_value[(int)_FunctionCall->_value_repeated_len++], offset);
	        	break;
	    }
	}
	
	return offset;
}

int FunctionCall_read_delimited_from(void *_buffer, struct FunctionCall *_FunctionCall, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	FunctionCall_read(_buffer, _FunctionCall, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 70
 *******************************************************************/

void FunctionReturn_clear(struct FunctionReturn *_FunctionReturn) {
	_memset(_FunctionReturn, 0, sizeof(struct FunctionReturn));
}

void FunctionReturn_init_optional_attributes(struct FunctionReturn *_FunctionReturn) {
	_FunctionReturn->_name_len = 0;
	
	
}

int FunctionReturn_is_default_message(struct FunctionReturn *_FunctionReturn) {
    return _FunctionReturn->_name_len == 0;
    
    /* Ignore DataValue */
}

int FunctionReturn_write(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_FunctionReturn->_name_len != 1
	    || _FunctionReturn->_name[0] != '0') {
		offset = write_raw_varint32((1<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_FunctionReturn->_name_len, _buffer, offset);
	    offset = write_raw_bytes(_FunctionReturn->_name, _FunctionReturn->_name_len, _buffer, offset);
	}
	
	int value_cnt;
	for (value_cnt = 0; value_cnt < _FunctionReturn->_value_repeated_len; ++ value_cnt) {
	    offset = DataValue_write_with_tag(&_FunctionReturn->_value[value_cnt], _buffer, offset, 2);
	}
	
	return offset;
}

int FunctionReturn_write_with_tag(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = FunctionReturn_write_delimited_to(_FunctionReturn, _buffer, offset);
	
	return offset;
}

int FunctionReturn_write_delimited_to(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = FunctionReturn_write(_FunctionReturn, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int FunctionReturn_read(void *_buffer, struct FunctionReturn *_FunctionReturn, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	FunctionReturn_clear(_FunctionReturn);
	/* Assign the optional attributes. */
	FunctionReturn_init_optional_attributes(_FunctionReturn);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _FunctionReturn._name */
	        case 1 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_FunctionReturn->_name_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_FunctionReturn->_name + i), _buffer, offset);
	        	break;
	        /* tag of: _FunctionReturn._value */
	        case 2 :
	        	offset = DataValue_read_delimited_from(_buffer, &_FunctionReturn->_value[(int)_FunctionReturn->_value_repeated_len++], offset);
	        	break;
	    }
	}
	
	return offset;
}

int FunctionReturn_read_delimited_from(void *_buffer, struct FunctionReturn *_FunctionReturn, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	FunctionReturn_read(_buffer, _FunctionReturn, offset, size + offset);
	
	return offset + size;
}
/*******************************************************************
 * Message: Spark.proto, line 91
 *******************************************************************/

void Envelope_clear(struct Envelope *_Envelope) {
	_memset(_Envelope, 0, sizeof(struct Envelope));
}

void Envelope_init_optional_attributes(struct Envelope *_Envelope) {
	_Envelope->_counter = 0;
	
	_Envelope->_type = 0;
	
	VariableRequest_init_optional_attributes(&_Envelope->_variablerequest);
	
	VariableValue_init_optional_attributes(&_Envelope->_variablevalue);
	
	FunctionCall_init_optional_attributes(&_Envelope->_functioncall);
	
	FunctionReturn_init_optional_attributes(&_Envelope->_functionreturn);
	
	Event_init_optional_attributes(&_Envelope->_event);
	
	Ignored_init_optional_attributes(&_Envelope->_ignored);
	
	Chunk_init_optional_attributes(&_Envelope->_chunk);
	
	ChunkReceived_init_optional_attributes(&_Envelope->_chunkreceived);
	
	KeyChange_init_optional_attributes(&_Envelope->_keychange);
	
}

int Envelope_is_default_message(struct Envelope *_Envelope) {
    return _Envelope->_counter == 0
    
     && _Envelope->_type == 0
    
     && VariableRequest_is_default_message(&_Envelope->_variablerequest)
    
     && VariableValue_is_default_message(&_Envelope->_variablevalue)
    
     && FunctionCall_is_default_message(&_Envelope->_functioncall)
    
     && FunctionReturn_is_default_message(&_Envelope->_functionreturn)
    
     && Event_is_default_message(&_Envelope->_event)
    
     && Ignored_is_default_message(&_Envelope->_ignored)
    
     && Chunk_is_default_message(&_Envelope->_chunk)
    
     && ChunkReceived_is_default_message(&_Envelope->_chunkreceived)
    
     && KeyChange_is_default_message(&_Envelope->_keychange)
    ;
}

int Envelope_write(struct Envelope *_Envelope, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_Envelope->_counter != 0) {
		offset = write_raw_varint32((1<<3)+0, _buffer, offset);
	    offset = write_raw_varint32(_Envelope->_counter, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_Envelope->_type != 0) {
	    offset = Type_write_with_tag(&_Envelope->_type, _buffer, offset, 2);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!VariableRequest_is_default_message(&_Envelope->_variablerequest)) {
	    offset = VariableRequest_write_with_tag(&_Envelope->_variablerequest, _buffer, offset, 3);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!VariableValue_is_default_message(&_Envelope->_variablevalue)) {
	    offset = VariableValue_write_with_tag(&_Envelope->_variablevalue, _buffer, offset, 4);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!FunctionCall_is_default_message(&_Envelope->_functioncall)) {
	    offset = FunctionCall_write_with_tag(&_Envelope->_functioncall, _buffer, offset, 5);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!FunctionReturn_is_default_message(&_Envelope->_functionreturn)) {
	    offset = FunctionReturn_write_with_tag(&_Envelope->_functionreturn, _buffer, offset, 6);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!Event_is_default_message(&_Envelope->_event)) {
	    offset = Event_write_with_tag(&_Envelope->_event, _buffer, offset, 7);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!Ignored_is_default_message(&_Envelope->_ignored)) {
	    offset = Ignored_write_with_tag(&_Envelope->_ignored, _buffer, offset, 8);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!Chunk_is_default_message(&_Envelope->_chunk)) {
	    offset = Chunk_write_with_tag(&_Envelope->_chunk, _buffer, offset, 9);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!ChunkReceived_is_default_message(&_Envelope->_chunkreceived)) {
	    offset = ChunkReceived_write_with_tag(&_Envelope->_chunkreceived, _buffer, offset, 10);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(!KeyChange_is_default_message(&_Envelope->_keychange)) {
	    offset = KeyChange_write_with_tag(&_Envelope->_keychange, _buffer, offset, 11);
	}
	
	return offset;
}

int Envelope_write_with_tag(struct Envelope *_Envelope, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = Envelope_write_delimited_to(_Envelope, _buffer, offset);
	
	return offset;
}

int Envelope_write_delimited_to(struct Envelope *_Envelope, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = Envelope_write(_Envelope, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int Envelope_read(void *_buffer, struct Envelope *_Envelope, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	Envelope_clear(_Envelope);
	/* Assign the optional attributes. */
	Envelope_init_optional_attributes(_Envelope);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _Envelope._counter */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Envelope->_counter = tag;
	        	break;
	        /* tag of: _Envelope._type */
	        case 2 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_Envelope->_type = tag;
	        	break;
	        /* tag of: _Envelope._variablerequest */
	        case 3 :
	        	offset = VariableRequest_read_delimited_from(_buffer, &_Envelope->_variablerequest, offset);
	        	break;
	        /* tag of: _Envelope._variablevalue */
	        case 4 :
	        	offset = VariableValue_read_delimited_from(_buffer, &_Envelope->_variablevalue, offset);
	        	break;
	        /* tag of: _Envelope._functioncall */
	        case 5 :
	        	offset = FunctionCall_read_delimited_from(_buffer, &_Envelope->_functioncall, offset);
	        	break;
	        /* tag of: _Envelope._functionreturn */
	        case 6 :
	        	offset = FunctionReturn_read_delimited_from(_buffer, &_Envelope->_functionreturn, offset);
	        	break;
	        /* tag of: _Envelope._event */
	        case 7 :
	        	offset = Event_read_delimited_from(_buffer, &_Envelope->_event, offset);
	        	break;
	        /* tag of: _Envelope._ignored */
	        case 8 :
	        	offset = Ignored_read_delimited_from(_buffer, &_Envelope->_ignored, offset);
	        	break;
	        /* tag of: _Envelope._chunk */
	        case 9 :
	        	offset = Chunk_read_delimited_from(_buffer, &_Envelope->_chunk, offset);
	        	break;
	        /* tag of: _Envelope._chunkreceived */
	        case 10 :
	        	offset = ChunkReceived_read_delimited_from(_buffer, &_Envelope->_chunkreceived, offset);
	        	break;
	        /* tag of: _Envelope._keychange */
	        case 11 :
	        	offset = KeyChange_read_delimited_from(_buffer, &_Envelope->_keychange, offset);
	        	break;
	    }
	}
	
	return offset;
}

int Envelope_read_delimited_from(void *_buffer, struct Envelope *_Envelope, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	Envelope_read(_buffer, _Envelope, offset, size + offset);
	
	return offset + size;
}
