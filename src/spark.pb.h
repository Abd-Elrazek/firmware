// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spark.proto

#ifndef PROTOBUF_spark_2eproto__INCLUDED
#define PROTOBUF_spark_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace spark {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_spark_2eproto();
void protobuf_AssignDesc_spark_2eproto();
void protobuf_ShutdownFile_spark_2eproto();

class DataValue;
class Chunk;
class ChunkReceived;
class Event;
class Hello;
class Ignored;
class KeyChange;
class UpdateBegin;
class UpdateDone;
class UpdateReady;
class VariableRequest;
class VariableValue;
class FunctionCall;
class FunctionReturn;
class Envelope;

enum DataType {
  STRING = 1,
  INT32 = 2,
  DOUBLE = 3,
  BOOL = 4,
  BYTES = 5
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = STRING;
const DataType DataType_MAX = BYTES;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum Type {
  CHUNK = 1,
  CHUNKRECEIVED = 2,
  EVENT = 3,
  FUNCTIONCALL = 4,
  FUNCTIONRETURN = 5,
  HELLO = 6,
  IGNORED = 7,
  KEYCHANGE = 8,
  UPDATEBEGIN = 9,
  UPDATEDONE = 10,
  UPDATEREADY = 11,
  VARIABLEREQUEST = 12,
  VARIABLEVALUE = 13
};
bool Type_IsValid(int value);
const Type Type_MIN = CHUNK;
const Type Type_MAX = VARIABLEVALUE;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class DataValue : public ::google::protobuf::Message {
 public:
  DataValue();
  virtual ~DataValue();

  DataValue(const DataValue& from);

  inline DataValue& operator=(const DataValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataValue& default_instance();

  void Swap(DataValue* other);

  // implements Message ----------------------------------------------

  DataValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataValue& from);
  void MergeFrom(const DataValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .spark.DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::spark::DataType type() const;
  inline void set_type(::spark::DataType value);

  // optional string vString = 2;
  inline bool has_vstring() const;
  inline void clear_vstring();
  static const int kVStringFieldNumber = 2;
  inline const ::std::string& vstring() const;
  inline void set_vstring(const ::std::string& value);
  inline void set_vstring(const char* value);
  inline void set_vstring(const char* value, size_t size);
  inline ::std::string* mutable_vstring();
  inline ::std::string* release_vstring();
  inline void set_allocated_vstring(::std::string* vstring);

  // optional int32 vInt = 3;
  inline bool has_vint() const;
  inline void clear_vint();
  static const int kVIntFieldNumber = 3;
  inline ::google::protobuf::int32 vint() const;
  inline void set_vint(::google::protobuf::int32 value);

  // optional double vDouble = 4;
  inline bool has_vdouble() const;
  inline void clear_vdouble();
  static const int kVDoubleFieldNumber = 4;
  inline double vdouble() const;
  inline void set_vdouble(double value);

  // optional bool vBool = 5;
  inline bool has_vbool() const;
  inline void clear_vbool();
  static const int kVBoolFieldNumber = 5;
  inline bool vbool() const;
  inline void set_vbool(bool value);

  // optional bytes vBytes = 6;
  inline bool has_vbytes() const;
  inline void clear_vbytes();
  static const int kVBytesFieldNumber = 6;
  inline const ::std::string& vbytes() const;
  inline void set_vbytes(const ::std::string& value);
  inline void set_vbytes(const char* value);
  inline void set_vbytes(const void* value, size_t size);
  inline ::std::string* mutable_vbytes();
  inline ::std::string* release_vbytes();
  inline void set_allocated_vbytes(::std::string* vbytes);

  // @@protoc_insertion_point(class_scope:spark.DataValue)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vstring();
  inline void clear_has_vstring();
  inline void set_has_vint();
  inline void clear_has_vint();
  inline void set_has_vdouble();
  inline void clear_has_vdouble();
  inline void set_has_vbool();
  inline void clear_has_vbool();
  inline void set_has_vbytes();
  inline void clear_has_vbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vstring_;
  int type_;
  ::google::protobuf::int32 vint_;
  double vdouble_;
  ::std::string* vbytes_;
  bool vbool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static DataValue* default_instance_;
};
// -------------------------------------------------------------------

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();

  Chunk(const Chunk& from);

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();

  void Swap(Chunk* other);

  // implements Message ----------------------------------------------

  Chunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes crc = 1;
  inline bool has_crc() const;
  inline void clear_crc();
  static const int kCrcFieldNumber = 1;
  inline const ::std::string& crc() const;
  inline void set_crc(const ::std::string& value);
  inline void set_crc(const char* value);
  inline void set_crc(const void* value, size_t size);
  inline ::std::string* mutable_crc();
  inline ::std::string* release_crc();
  inline void set_allocated_crc(::std::string* crc);

  // optional uint32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:spark.Chunk)
 private:
  inline void set_has_crc();
  inline void clear_has_crc();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crc_;
  ::std::string* data_;
  ::google::protobuf::uint32 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class ChunkReceived : public ::google::protobuf::Message {
 public:
  ChunkReceived();
  virtual ~ChunkReceived();

  ChunkReceived(const ChunkReceived& from);

  inline ChunkReceived& operator=(const ChunkReceived& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChunkReceived& default_instance();

  void Swap(ChunkReceived* other);

  // implements Message ----------------------------------------------

  ChunkReceived* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChunkReceived& from);
  void MergeFrom(const ChunkReceived& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes crc = 1;
  inline bool has_crc() const;
  inline void clear_crc();
  static const int kCrcFieldNumber = 1;
  inline const ::std::string& crc() const;
  inline void set_crc(const ::std::string& value);
  inline void set_crc(const char* value);
  inline void set_crc(const void* value, size_t size);
  inline ::std::string* mutable_crc();
  inline ::std::string* release_crc();
  inline void set_allocated_crc(::std::string* crc);

  // @@protoc_insertion_point(class_scope:spark.ChunkReceived)
 private:
  inline void set_has_crc();
  inline void clear_has_crc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static ChunkReceived* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:spark.Event)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class Hello : public ::google::protobuf::Message {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  Hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spark.Hello)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static Hello* default_instance_;
};
// -------------------------------------------------------------------

class Ignored : public ::google::protobuf::Message {
 public:
  Ignored();
  virtual ~Ignored();

  Ignored(const Ignored& from);

  inline Ignored& operator=(const Ignored& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ignored& default_instance();

  void Swap(Ignored* other);

  // implements Message ----------------------------------------------

  Ignored* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ignored& from);
  void MergeFrom(const Ignored& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 received = 1;
  inline bool has_received() const;
  inline void clear_received();
  static const int kReceivedFieldNumber = 1;
  inline ::google::protobuf::uint32 received() const;
  inline void set_received(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:spark.Ignored)
 private:
  inline void set_has_received();
  inline void clear_has_received();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 received_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static Ignored* default_instance_;
};
// -------------------------------------------------------------------

class KeyChange : public ::google::protobuf::Message {
 public:
  KeyChange();
  virtual ~KeyChange();

  KeyChange(const KeyChange& from);

  inline KeyChange& operator=(const KeyChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyChange& default_instance();

  void Swap(KeyChange* other);

  // implements Message ----------------------------------------------

  KeyChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyChange& from);
  void MergeFrom(const KeyChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ciphertext = 1;
  inline bool has_ciphertext() const;
  inline void clear_ciphertext();
  static const int kCiphertextFieldNumber = 1;
  inline const ::std::string& ciphertext() const;
  inline void set_ciphertext(const ::std::string& value);
  inline void set_ciphertext(const char* value);
  inline void set_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_ciphertext();
  inline ::std::string* release_ciphertext();
  inline void set_allocated_ciphertext(::std::string* ciphertext);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:spark.KeyChange)
 private:
  inline void set_has_ciphertext();
  inline void clear_has_ciphertext();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ciphertext_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static KeyChange* default_instance_;
};
// -------------------------------------------------------------------

class UpdateBegin : public ::google::protobuf::Message {
 public:
  UpdateBegin();
  virtual ~UpdateBegin();

  UpdateBegin(const UpdateBegin& from);

  inline UpdateBegin& operator=(const UpdateBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateBegin& default_instance();

  void Swap(UpdateBegin* other);

  // implements Message ----------------------------------------------

  UpdateBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateBegin& from);
  void MergeFrom(const UpdateBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spark.UpdateBegin)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static UpdateBegin* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDone : public ::google::protobuf::Message {
 public:
  UpdateDone();
  virtual ~UpdateDone();

  UpdateDone(const UpdateDone& from);

  inline UpdateDone& operator=(const UpdateDone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDone& default_instance();

  void Swap(UpdateDone* other);

  // implements Message ----------------------------------------------

  UpdateDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDone& from);
  void MergeFrom(const UpdateDone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spark.UpdateDone)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static UpdateDone* default_instance_;
};
// -------------------------------------------------------------------

class UpdateReady : public ::google::protobuf::Message {
 public:
  UpdateReady();
  virtual ~UpdateReady();

  UpdateReady(const UpdateReady& from);

  inline UpdateReady& operator=(const UpdateReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateReady& default_instance();

  void Swap(UpdateReady* other);

  // implements Message ----------------------------------------------

  UpdateReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateReady& from);
  void MergeFrom(const UpdateReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:spark.UpdateReady)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static UpdateReady* default_instance_;
};
// -------------------------------------------------------------------

class VariableRequest : public ::google::protobuf::Message {
 public:
  VariableRequest();
  virtual ~VariableRequest();

  VariableRequest(const VariableRequest& from);

  inline VariableRequest& operator=(const VariableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VariableRequest& default_instance();

  void Swap(VariableRequest* other);

  // implements Message ----------------------------------------------

  VariableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VariableRequest& from);
  void MergeFrom(const VariableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool set = 2;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 2;
  inline bool set() const;
  inline void set_set(bool value);

  // repeated .spark.DataValue value = 3;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::spark::DataValue& value(int index) const;
  inline ::spark::DataValue* mutable_value(int index);
  inline ::spark::DataValue* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:spark.VariableRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_set();
  inline void clear_has_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::spark::DataValue > value_;
  bool set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static VariableRequest* default_instance_;
};
// -------------------------------------------------------------------

class VariableValue : public ::google::protobuf::Message {
 public:
  VariableValue();
  virtual ~VariableValue();

  VariableValue(const VariableValue& from);

  inline VariableValue& operator=(const VariableValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VariableValue& default_instance();

  void Swap(VariableValue* other);

  // implements Message ----------------------------------------------

  VariableValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VariableValue& from);
  void MergeFrom(const VariableValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .spark.DataValue value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::spark::DataValue& value(int index) const;
  inline ::spark::DataValue* mutable_value(int index);
  inline ::spark::DataValue* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:spark.VariableValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::spark::DataValue > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static VariableValue* default_instance_;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();

  void Swap(FunctionCall* other);

  // implements Message ----------------------------------------------

  FunctionCall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string argNames = 2;
  inline int argnames_size() const;
  inline void clear_argnames();
  static const int kArgNamesFieldNumber = 2;
  inline const ::std::string& argnames(int index) const;
  inline ::std::string* mutable_argnames(int index);
  inline void set_argnames(int index, const ::std::string& value);
  inline void set_argnames(int index, const char* value);
  inline void set_argnames(int index, const char* value, size_t size);
  inline ::std::string* add_argnames();
  inline void add_argnames(const ::std::string& value);
  inline void add_argnames(const char* value);
  inline void add_argnames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& argnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argnames();

  // repeated .spark.DataValue value = 3;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::spark::DataValue& value(int index) const;
  inline ::spark::DataValue* mutable_value(int index);
  inline ::spark::DataValue* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:spark.FunctionCall)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argnames_;
  ::google::protobuf::RepeatedPtrField< ::spark::DataValue > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static FunctionCall* default_instance_;
};
// -------------------------------------------------------------------

class FunctionReturn : public ::google::protobuf::Message {
 public:
  FunctionReturn();
  virtual ~FunctionReturn();

  FunctionReturn(const FunctionReturn& from);

  inline FunctionReturn& operator=(const FunctionReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionReturn& default_instance();

  void Swap(FunctionReturn* other);

  // implements Message ----------------------------------------------

  FunctionReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionReturn& from);
  void MergeFrom(const FunctionReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .spark.DataValue value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::spark::DataValue& value(int index) const;
  inline ::spark::DataValue* mutable_value(int index);
  inline ::spark::DataValue* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:spark.FunctionReturn)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::spark::DataValue > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static FunctionReturn* default_instance_;
};
// -------------------------------------------------------------------

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 counter = 1;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 1;
  inline ::google::protobuf::uint32 counter() const;
  inline void set_counter(::google::protobuf::uint32 value);

  // optional .spark.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::spark::Type type() const;
  inline void set_type(::spark::Type value);

  // optional .spark.VariableRequest variablerequest = 3;
  inline bool has_variablerequest() const;
  inline void clear_variablerequest();
  static const int kVariablerequestFieldNumber = 3;
  inline const ::spark::VariableRequest& variablerequest() const;
  inline ::spark::VariableRequest* mutable_variablerequest();
  inline ::spark::VariableRequest* release_variablerequest();
  inline void set_allocated_variablerequest(::spark::VariableRequest* variablerequest);

  // optional .spark.VariableValue variablevalue = 4;
  inline bool has_variablevalue() const;
  inline void clear_variablevalue();
  static const int kVariablevalueFieldNumber = 4;
  inline const ::spark::VariableValue& variablevalue() const;
  inline ::spark::VariableValue* mutable_variablevalue();
  inline ::spark::VariableValue* release_variablevalue();
  inline void set_allocated_variablevalue(::spark::VariableValue* variablevalue);

  // optional .spark.FunctionCall functioncall = 5;
  inline bool has_functioncall() const;
  inline void clear_functioncall();
  static const int kFunctioncallFieldNumber = 5;
  inline const ::spark::FunctionCall& functioncall() const;
  inline ::spark::FunctionCall* mutable_functioncall();
  inline ::spark::FunctionCall* release_functioncall();
  inline void set_allocated_functioncall(::spark::FunctionCall* functioncall);

  // optional .spark.FunctionReturn functionreturn = 6;
  inline bool has_functionreturn() const;
  inline void clear_functionreturn();
  static const int kFunctionreturnFieldNumber = 6;
  inline const ::spark::FunctionReturn& functionreturn() const;
  inline ::spark::FunctionReturn* mutable_functionreturn();
  inline ::spark::FunctionReturn* release_functionreturn();
  inline void set_allocated_functionreturn(::spark::FunctionReturn* functionreturn);

  // optional .spark.Event event = 7;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 7;
  inline const ::spark::Event& event() const;
  inline ::spark::Event* mutable_event();
  inline ::spark::Event* release_event();
  inline void set_allocated_event(::spark::Event* event);

  // optional .spark.Ignored ignored = 8;
  inline bool has_ignored() const;
  inline void clear_ignored();
  static const int kIgnoredFieldNumber = 8;
  inline const ::spark::Ignored& ignored() const;
  inline ::spark::Ignored* mutable_ignored();
  inline ::spark::Ignored* release_ignored();
  inline void set_allocated_ignored(::spark::Ignored* ignored);

  // optional .spark.UpdateBegin updatebegin = 9;
  inline bool has_updatebegin() const;
  inline void clear_updatebegin();
  static const int kUpdatebeginFieldNumber = 9;
  inline const ::spark::UpdateBegin& updatebegin() const;
  inline ::spark::UpdateBegin* mutable_updatebegin();
  inline ::spark::UpdateBegin* release_updatebegin();
  inline void set_allocated_updatebegin(::spark::UpdateBegin* updatebegin);

  // optional .spark.UpdateReady updateready = 10;
  inline bool has_updateready() const;
  inline void clear_updateready();
  static const int kUpdatereadyFieldNumber = 10;
  inline const ::spark::UpdateReady& updateready() const;
  inline ::spark::UpdateReady* mutable_updateready();
  inline ::spark::UpdateReady* release_updateready();
  inline void set_allocated_updateready(::spark::UpdateReady* updateready);

  // optional .spark.Chunk chunk = 11;
  inline bool has_chunk() const;
  inline void clear_chunk();
  static const int kChunkFieldNumber = 11;
  inline const ::spark::Chunk& chunk() const;
  inline ::spark::Chunk* mutable_chunk();
  inline ::spark::Chunk* release_chunk();
  inline void set_allocated_chunk(::spark::Chunk* chunk);

  // optional .spark.ChunkReceived chunkreceived = 12;
  inline bool has_chunkreceived() const;
  inline void clear_chunkreceived();
  static const int kChunkreceivedFieldNumber = 12;
  inline const ::spark::ChunkReceived& chunkreceived() const;
  inline ::spark::ChunkReceived* mutable_chunkreceived();
  inline ::spark::ChunkReceived* release_chunkreceived();
  inline void set_allocated_chunkreceived(::spark::ChunkReceived* chunkreceived);

  // optional .spark.UpdateDone updatedone = 13;
  inline bool has_updatedone() const;
  inline void clear_updatedone();
  static const int kUpdatedoneFieldNumber = 13;
  inline const ::spark::UpdateDone& updatedone() const;
  inline ::spark::UpdateDone* mutable_updatedone();
  inline ::spark::UpdateDone* release_updatedone();
  inline void set_allocated_updatedone(::spark::UpdateDone* updatedone);

  // optional .spark.Hello hello = 14;
  inline bool has_hello() const;
  inline void clear_hello();
  static const int kHelloFieldNumber = 14;
  inline const ::spark::Hello& hello() const;
  inline ::spark::Hello* mutable_hello();
  inline ::spark::Hello* release_hello();
  inline void set_allocated_hello(::spark::Hello* hello);

  // optional .spark.KeyChange keychange = 15;
  inline bool has_keychange() const;
  inline void clear_keychange();
  static const int kKeychangeFieldNumber = 15;
  inline const ::spark::KeyChange& keychange() const;
  inline ::spark::KeyChange* mutable_keychange();
  inline ::spark::KeyChange* release_keychange();
  inline void set_allocated_keychange(::spark::KeyChange* keychange);

  // @@protoc_insertion_point(class_scope:spark.Envelope)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_variablerequest();
  inline void clear_has_variablerequest();
  inline void set_has_variablevalue();
  inline void clear_has_variablevalue();
  inline void set_has_functioncall();
  inline void clear_has_functioncall();
  inline void set_has_functionreturn();
  inline void clear_has_functionreturn();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_ignored();
  inline void clear_has_ignored();
  inline void set_has_updatebegin();
  inline void clear_has_updatebegin();
  inline void set_has_updateready();
  inline void clear_has_updateready();
  inline void set_has_chunk();
  inline void clear_has_chunk();
  inline void set_has_chunkreceived();
  inline void clear_has_chunkreceived();
  inline void set_has_updatedone();
  inline void clear_has_updatedone();
  inline void set_has_hello();
  inline void clear_has_hello();
  inline void set_has_keychange();
  inline void clear_has_keychange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 counter_;
  int type_;
  ::spark::VariableRequest* variablerequest_;
  ::spark::VariableValue* variablevalue_;
  ::spark::FunctionCall* functioncall_;
  ::spark::FunctionReturn* functionreturn_;
  ::spark::Event* event_;
  ::spark::Ignored* ignored_;
  ::spark::UpdateBegin* updatebegin_;
  ::spark::UpdateReady* updateready_;
  ::spark::Chunk* chunk_;
  ::spark::ChunkReceived* chunkreceived_;
  ::spark::UpdateDone* updatedone_;
  ::spark::Hello* hello_;
  ::spark::KeyChange* keychange_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_spark_2eproto();
  friend void protobuf_AssignDesc_spark_2eproto();
  friend void protobuf_ShutdownFile_spark_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// ===================================================================


// ===================================================================

// DataValue

// optional .spark.DataType type = 1;
inline bool DataValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataValue::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::spark::DataType DataValue::type() const {
  return static_cast< ::spark::DataType >(type_);
}
inline void DataValue::set_type(::spark::DataType value) {
  assert(::spark::DataType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string vString = 2;
inline bool DataValue::has_vstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataValue::set_has_vstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataValue::clear_has_vstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataValue::clear_vstring() {
  if (vstring_ != &::google::protobuf::internal::kEmptyString) {
    vstring_->clear();
  }
  clear_has_vstring();
}
inline const ::std::string& DataValue::vstring() const {
  return *vstring_;
}
inline void DataValue::set_vstring(const ::std::string& value) {
  set_has_vstring();
  if (vstring_ == &::google::protobuf::internal::kEmptyString) {
    vstring_ = new ::std::string;
  }
  vstring_->assign(value);
}
inline void DataValue::set_vstring(const char* value) {
  set_has_vstring();
  if (vstring_ == &::google::protobuf::internal::kEmptyString) {
    vstring_ = new ::std::string;
  }
  vstring_->assign(value);
}
inline void DataValue::set_vstring(const char* value, size_t size) {
  set_has_vstring();
  if (vstring_ == &::google::protobuf::internal::kEmptyString) {
    vstring_ = new ::std::string;
  }
  vstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataValue::mutable_vstring() {
  set_has_vstring();
  if (vstring_ == &::google::protobuf::internal::kEmptyString) {
    vstring_ = new ::std::string;
  }
  return vstring_;
}
inline ::std::string* DataValue::release_vstring() {
  clear_has_vstring();
  if (vstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vstring_;
    vstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataValue::set_allocated_vstring(::std::string* vstring) {
  if (vstring_ != &::google::protobuf::internal::kEmptyString) {
    delete vstring_;
  }
  if (vstring) {
    set_has_vstring();
    vstring_ = vstring;
  } else {
    clear_has_vstring();
    vstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 vInt = 3;
inline bool DataValue::has_vint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataValue::set_has_vint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataValue::clear_has_vint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataValue::clear_vint() {
  vint_ = 0;
  clear_has_vint();
}
inline ::google::protobuf::int32 DataValue::vint() const {
  return vint_;
}
inline void DataValue::set_vint(::google::protobuf::int32 value) {
  set_has_vint();
  vint_ = value;
}

// optional double vDouble = 4;
inline bool DataValue::has_vdouble() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataValue::set_has_vdouble() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataValue::clear_has_vdouble() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataValue::clear_vdouble() {
  vdouble_ = 0;
  clear_has_vdouble();
}
inline double DataValue::vdouble() const {
  return vdouble_;
}
inline void DataValue::set_vdouble(double value) {
  set_has_vdouble();
  vdouble_ = value;
}

// optional bool vBool = 5;
inline bool DataValue::has_vbool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataValue::set_has_vbool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataValue::clear_has_vbool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataValue::clear_vbool() {
  vbool_ = false;
  clear_has_vbool();
}
inline bool DataValue::vbool() const {
  return vbool_;
}
inline void DataValue::set_vbool(bool value) {
  set_has_vbool();
  vbool_ = value;
}

// optional bytes vBytes = 6;
inline bool DataValue::has_vbytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataValue::set_has_vbytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataValue::clear_has_vbytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataValue::clear_vbytes() {
  if (vbytes_ != &::google::protobuf::internal::kEmptyString) {
    vbytes_->clear();
  }
  clear_has_vbytes();
}
inline const ::std::string& DataValue::vbytes() const {
  return *vbytes_;
}
inline void DataValue::set_vbytes(const ::std::string& value) {
  set_has_vbytes();
  if (vbytes_ == &::google::protobuf::internal::kEmptyString) {
    vbytes_ = new ::std::string;
  }
  vbytes_->assign(value);
}
inline void DataValue::set_vbytes(const char* value) {
  set_has_vbytes();
  if (vbytes_ == &::google::protobuf::internal::kEmptyString) {
    vbytes_ = new ::std::string;
  }
  vbytes_->assign(value);
}
inline void DataValue::set_vbytes(const void* value, size_t size) {
  set_has_vbytes();
  if (vbytes_ == &::google::protobuf::internal::kEmptyString) {
    vbytes_ = new ::std::string;
  }
  vbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataValue::mutable_vbytes() {
  set_has_vbytes();
  if (vbytes_ == &::google::protobuf::internal::kEmptyString) {
    vbytes_ = new ::std::string;
  }
  return vbytes_;
}
inline ::std::string* DataValue::release_vbytes() {
  clear_has_vbytes();
  if (vbytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vbytes_;
    vbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataValue::set_allocated_vbytes(::std::string* vbytes) {
  if (vbytes_ != &::google::protobuf::internal::kEmptyString) {
    delete vbytes_;
  }
  if (vbytes) {
    set_has_vbytes();
    vbytes_ = vbytes;
  } else {
    clear_has_vbytes();
    vbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Chunk

// optional bytes crc = 1;
inline bool Chunk::has_crc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chunk::set_has_crc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chunk::clear_has_crc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chunk::clear_crc() {
  if (crc_ != &::google::protobuf::internal::kEmptyString) {
    crc_->clear();
  }
  clear_has_crc();
}
inline const ::std::string& Chunk::crc() const {
  return *crc_;
}
inline void Chunk::set_crc(const ::std::string& value) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(value);
}
inline void Chunk::set_crc(const char* value) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(value);
}
inline void Chunk::set_crc(const void* value, size_t size) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_crc() {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  return crc_;
}
inline ::std::string* Chunk::release_crc() {
  clear_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crc_;
    crc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chunk::set_allocated_crc(::std::string* crc) {
  if (crc_ != &::google::protobuf::internal::kEmptyString) {
    delete crc_;
  }
  if (crc) {
    set_has_crc();
    crc_ = crc;
  } else {
    clear_has_crc();
    crc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 length = 2;
inline bool Chunk::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Chunk::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Chunk::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Chunk::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 Chunk::length() const {
  return length_;
}
inline void Chunk::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// optional bytes data = 3;
inline bool Chunk::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Chunk::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Chunk::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Chunk::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Chunk::data() const {
  return *data_;
}
inline void Chunk::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Chunk::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Chunk::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Chunk::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chunk::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChunkReceived

// optional bytes crc = 1;
inline bool ChunkReceived::has_crc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChunkReceived::set_has_crc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChunkReceived::clear_has_crc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChunkReceived::clear_crc() {
  if (crc_ != &::google::protobuf::internal::kEmptyString) {
    crc_->clear();
  }
  clear_has_crc();
}
inline const ::std::string& ChunkReceived::crc() const {
  return *crc_;
}
inline void ChunkReceived::set_crc(const ::std::string& value) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(value);
}
inline void ChunkReceived::set_crc(const char* value) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(value);
}
inline void ChunkReceived::set_crc(const void* value, size_t size) {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  crc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChunkReceived::mutable_crc() {
  set_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    crc_ = new ::std::string;
  }
  return crc_;
}
inline ::std::string* ChunkReceived::release_crc() {
  clear_has_crc();
  if (crc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crc_;
    crc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChunkReceived::set_allocated_crc(::std::string* crc) {
  if (crc_ != &::google::protobuf::internal::kEmptyString) {
    delete crc_;
  }
  if (crc) {
    set_has_crc();
    crc_ = crc;
  } else {
    clear_has_crc();
    crc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Event

// optional string name = 1;
inline bool Event::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Event::name() const {
  return *name_;
}
inline void Event::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Event::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Event::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Event::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data = 2;
inline bool Event::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Event::data() const {
  return *data_;
}
inline void Event::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Event::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Event::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Event::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Hello

// -------------------------------------------------------------------

// Ignored

// optional uint32 received = 1;
inline bool Ignored::has_received() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ignored::set_has_received() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ignored::clear_has_received() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ignored::clear_received() {
  received_ = 0u;
  clear_has_received();
}
inline ::google::protobuf::uint32 Ignored::received() const {
  return received_;
}
inline void Ignored::set_received(::google::protobuf::uint32 value) {
  set_has_received();
  received_ = value;
}

// -------------------------------------------------------------------

// KeyChange

// optional bytes ciphertext = 1;
inline bool KeyChange::has_ciphertext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyChange::set_has_ciphertext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyChange::clear_has_ciphertext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyChange::clear_ciphertext() {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    ciphertext_->clear();
  }
  clear_has_ciphertext();
}
inline const ::std::string& KeyChange::ciphertext() const {
  return *ciphertext_;
}
inline void KeyChange::set_ciphertext(const ::std::string& value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void KeyChange::set_ciphertext(const char* value) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(value);
}
inline void KeyChange::set_ciphertext(const void* value, size_t size) {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  ciphertext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyChange::mutable_ciphertext() {
  set_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    ciphertext_ = new ::std::string;
  }
  return ciphertext_;
}
inline ::std::string* KeyChange::release_ciphertext() {
  clear_has_ciphertext();
  if (ciphertext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ciphertext_;
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyChange::set_allocated_ciphertext(::std::string* ciphertext) {
  if (ciphertext_ != &::google::protobuf::internal::kEmptyString) {
    delete ciphertext_;
  }
  if (ciphertext) {
    set_has_ciphertext();
    ciphertext_ = ciphertext;
  } else {
    clear_has_ciphertext();
    ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool KeyChange::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyChange::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyChange::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyChange::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& KeyChange::signature() const {
  return *signature_;
}
inline void KeyChange::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void KeyChange::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void KeyChange::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyChange::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* KeyChange::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyChange::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateBegin

// -------------------------------------------------------------------

// UpdateDone

// -------------------------------------------------------------------

// UpdateReady

// -------------------------------------------------------------------

// VariableRequest

// optional string name = 1;
inline bool VariableRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VariableRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VariableRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VariableRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VariableRequest::name() const {
  return *name_;
}
inline void VariableRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VariableRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VariableRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VariableRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VariableRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VariableRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool set = 2;
inline bool VariableRequest::has_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VariableRequest::set_has_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VariableRequest::clear_has_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VariableRequest::clear_set() {
  set_ = false;
  clear_has_set();
}
inline bool VariableRequest::set() const {
  return set_;
}
inline void VariableRequest::set_set(bool value) {
  set_has_set();
  set_ = value;
}

// repeated .spark.DataValue value = 3;
inline int VariableRequest::value_size() const {
  return value_.size();
}
inline void VariableRequest::clear_value() {
  value_.Clear();
}
inline const ::spark::DataValue& VariableRequest::value(int index) const {
  return value_.Get(index);
}
inline ::spark::DataValue* VariableRequest::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::spark::DataValue* VariableRequest::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
VariableRequest::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
VariableRequest::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// VariableValue

// optional string name = 1;
inline bool VariableValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VariableValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VariableValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VariableValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VariableValue::name() const {
  return *name_;
}
inline void VariableValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VariableValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VariableValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VariableValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VariableValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VariableValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .spark.DataValue value = 2;
inline int VariableValue::value_size() const {
  return value_.size();
}
inline void VariableValue::clear_value() {
  value_.Clear();
}
inline const ::spark::DataValue& VariableValue::value(int index) const {
  return value_.Get(index);
}
inline ::spark::DataValue* VariableValue::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::spark::DataValue* VariableValue::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
VariableValue::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
VariableValue::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// FunctionCall

// optional string name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FunctionCall::name() const {
  return *name_;
}
inline void FunctionCall::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionCall::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FunctionCall::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionCall::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string argNames = 2;
inline int FunctionCall::argnames_size() const {
  return argnames_.size();
}
inline void FunctionCall::clear_argnames() {
  argnames_.Clear();
}
inline const ::std::string& FunctionCall::argnames(int index) const {
  return argnames_.Get(index);
}
inline ::std::string* FunctionCall::mutable_argnames(int index) {
  return argnames_.Mutable(index);
}
inline void FunctionCall::set_argnames(int index, const ::std::string& value) {
  argnames_.Mutable(index)->assign(value);
}
inline void FunctionCall::set_argnames(int index, const char* value) {
  argnames_.Mutable(index)->assign(value);
}
inline void FunctionCall::set_argnames(int index, const char* value, size_t size) {
  argnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionCall::add_argnames() {
  return argnames_.Add();
}
inline void FunctionCall::add_argnames(const ::std::string& value) {
  argnames_.Add()->assign(value);
}
inline void FunctionCall::add_argnames(const char* value) {
  argnames_.Add()->assign(value);
}
inline void FunctionCall::add_argnames(const char* value, size_t size) {
  argnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FunctionCall::argnames() const {
  return argnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FunctionCall::mutable_argnames() {
  return &argnames_;
}

// repeated .spark.DataValue value = 3;
inline int FunctionCall::value_size() const {
  return value_.size();
}
inline void FunctionCall::clear_value() {
  value_.Clear();
}
inline const ::spark::DataValue& FunctionCall::value(int index) const {
  return value_.Get(index);
}
inline ::spark::DataValue* FunctionCall::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::spark::DataValue* FunctionCall::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
FunctionCall::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
FunctionCall::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// FunctionReturn

// optional string name = 1;
inline bool FunctionReturn::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionReturn::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionReturn::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionReturn::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FunctionReturn::name() const {
  return *name_;
}
inline void FunctionReturn::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionReturn::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FunctionReturn::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FunctionReturn::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FunctionReturn::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FunctionReturn::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .spark.DataValue value = 2;
inline int FunctionReturn::value_size() const {
  return value_.size();
}
inline void FunctionReturn::clear_value() {
  value_.Clear();
}
inline const ::spark::DataValue& FunctionReturn::value(int index) const {
  return value_.Get(index);
}
inline ::spark::DataValue* FunctionReturn::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::spark::DataValue* FunctionReturn::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spark::DataValue >&
FunctionReturn::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::spark::DataValue >*
FunctionReturn::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Envelope

// optional uint32 counter = 1;
inline bool Envelope::has_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_counter() {
  counter_ = 0u;
  clear_has_counter();
}
inline ::google::protobuf::uint32 Envelope::counter() const {
  return counter_;
}
inline void Envelope::set_counter(::google::protobuf::uint32 value) {
  set_has_counter();
  counter_ = value;
}

// optional .spark.Type type = 2;
inline bool Envelope::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::spark::Type Envelope::type() const {
  return static_cast< ::spark::Type >(type_);
}
inline void Envelope::set_type(::spark::Type value) {
  assert(::spark::Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .spark.VariableRequest variablerequest = 3;
inline bool Envelope::has_variablerequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_variablerequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_variablerequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_variablerequest() {
  if (variablerequest_ != NULL) variablerequest_->::spark::VariableRequest::Clear();
  clear_has_variablerequest();
}
inline const ::spark::VariableRequest& Envelope::variablerequest() const {
  return variablerequest_ != NULL ? *variablerequest_ : *default_instance_->variablerequest_;
}
inline ::spark::VariableRequest* Envelope::mutable_variablerequest() {
  set_has_variablerequest();
  if (variablerequest_ == NULL) variablerequest_ = new ::spark::VariableRequest;
  return variablerequest_;
}
inline ::spark::VariableRequest* Envelope::release_variablerequest() {
  clear_has_variablerequest();
  ::spark::VariableRequest* temp = variablerequest_;
  variablerequest_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_variablerequest(::spark::VariableRequest* variablerequest) {
  delete variablerequest_;
  variablerequest_ = variablerequest;
  if (variablerequest) {
    set_has_variablerequest();
  } else {
    clear_has_variablerequest();
  }
}

// optional .spark.VariableValue variablevalue = 4;
inline bool Envelope::has_variablevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Envelope::set_has_variablevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Envelope::clear_has_variablevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Envelope::clear_variablevalue() {
  if (variablevalue_ != NULL) variablevalue_->::spark::VariableValue::Clear();
  clear_has_variablevalue();
}
inline const ::spark::VariableValue& Envelope::variablevalue() const {
  return variablevalue_ != NULL ? *variablevalue_ : *default_instance_->variablevalue_;
}
inline ::spark::VariableValue* Envelope::mutable_variablevalue() {
  set_has_variablevalue();
  if (variablevalue_ == NULL) variablevalue_ = new ::spark::VariableValue;
  return variablevalue_;
}
inline ::spark::VariableValue* Envelope::release_variablevalue() {
  clear_has_variablevalue();
  ::spark::VariableValue* temp = variablevalue_;
  variablevalue_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_variablevalue(::spark::VariableValue* variablevalue) {
  delete variablevalue_;
  variablevalue_ = variablevalue;
  if (variablevalue) {
    set_has_variablevalue();
  } else {
    clear_has_variablevalue();
  }
}

// optional .spark.FunctionCall functioncall = 5;
inline bool Envelope::has_functioncall() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Envelope::set_has_functioncall() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Envelope::clear_has_functioncall() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Envelope::clear_functioncall() {
  if (functioncall_ != NULL) functioncall_->::spark::FunctionCall::Clear();
  clear_has_functioncall();
}
inline const ::spark::FunctionCall& Envelope::functioncall() const {
  return functioncall_ != NULL ? *functioncall_ : *default_instance_->functioncall_;
}
inline ::spark::FunctionCall* Envelope::mutable_functioncall() {
  set_has_functioncall();
  if (functioncall_ == NULL) functioncall_ = new ::spark::FunctionCall;
  return functioncall_;
}
inline ::spark::FunctionCall* Envelope::release_functioncall() {
  clear_has_functioncall();
  ::spark::FunctionCall* temp = functioncall_;
  functioncall_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_functioncall(::spark::FunctionCall* functioncall) {
  delete functioncall_;
  functioncall_ = functioncall;
  if (functioncall) {
    set_has_functioncall();
  } else {
    clear_has_functioncall();
  }
}

// optional .spark.FunctionReturn functionreturn = 6;
inline bool Envelope::has_functionreturn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Envelope::set_has_functionreturn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Envelope::clear_has_functionreturn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Envelope::clear_functionreturn() {
  if (functionreturn_ != NULL) functionreturn_->::spark::FunctionReturn::Clear();
  clear_has_functionreturn();
}
inline const ::spark::FunctionReturn& Envelope::functionreturn() const {
  return functionreturn_ != NULL ? *functionreturn_ : *default_instance_->functionreturn_;
}
inline ::spark::FunctionReturn* Envelope::mutable_functionreturn() {
  set_has_functionreturn();
  if (functionreturn_ == NULL) functionreturn_ = new ::spark::FunctionReturn;
  return functionreturn_;
}
inline ::spark::FunctionReturn* Envelope::release_functionreturn() {
  clear_has_functionreturn();
  ::spark::FunctionReturn* temp = functionreturn_;
  functionreturn_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_functionreturn(::spark::FunctionReturn* functionreturn) {
  delete functionreturn_;
  functionreturn_ = functionreturn;
  if (functionreturn) {
    set_has_functionreturn();
  } else {
    clear_has_functionreturn();
  }
}

// optional .spark.Event event = 7;
inline bool Envelope::has_event() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Envelope::set_has_event() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Envelope::clear_has_event() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Envelope::clear_event() {
  if (event_ != NULL) event_->::spark::Event::Clear();
  clear_has_event();
}
inline const ::spark::Event& Envelope::event() const {
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::spark::Event* Envelope::mutable_event() {
  set_has_event();
  if (event_ == NULL) event_ = new ::spark::Event;
  return event_;
}
inline ::spark::Event* Envelope::release_event() {
  clear_has_event();
  ::spark::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_event(::spark::Event* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
}

// optional .spark.Ignored ignored = 8;
inline bool Envelope::has_ignored() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Envelope::set_has_ignored() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Envelope::clear_has_ignored() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Envelope::clear_ignored() {
  if (ignored_ != NULL) ignored_->::spark::Ignored::Clear();
  clear_has_ignored();
}
inline const ::spark::Ignored& Envelope::ignored() const {
  return ignored_ != NULL ? *ignored_ : *default_instance_->ignored_;
}
inline ::spark::Ignored* Envelope::mutable_ignored() {
  set_has_ignored();
  if (ignored_ == NULL) ignored_ = new ::spark::Ignored;
  return ignored_;
}
inline ::spark::Ignored* Envelope::release_ignored() {
  clear_has_ignored();
  ::spark::Ignored* temp = ignored_;
  ignored_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_ignored(::spark::Ignored* ignored) {
  delete ignored_;
  ignored_ = ignored;
  if (ignored) {
    set_has_ignored();
  } else {
    clear_has_ignored();
  }
}

// optional .spark.UpdateBegin updatebegin = 9;
inline bool Envelope::has_updatebegin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Envelope::set_has_updatebegin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Envelope::clear_has_updatebegin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Envelope::clear_updatebegin() {
  if (updatebegin_ != NULL) updatebegin_->::spark::UpdateBegin::Clear();
  clear_has_updatebegin();
}
inline const ::spark::UpdateBegin& Envelope::updatebegin() const {
  return updatebegin_ != NULL ? *updatebegin_ : *default_instance_->updatebegin_;
}
inline ::spark::UpdateBegin* Envelope::mutable_updatebegin() {
  set_has_updatebegin();
  if (updatebegin_ == NULL) updatebegin_ = new ::spark::UpdateBegin;
  return updatebegin_;
}
inline ::spark::UpdateBegin* Envelope::release_updatebegin() {
  clear_has_updatebegin();
  ::spark::UpdateBegin* temp = updatebegin_;
  updatebegin_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_updatebegin(::spark::UpdateBegin* updatebegin) {
  delete updatebegin_;
  updatebegin_ = updatebegin;
  if (updatebegin) {
    set_has_updatebegin();
  } else {
    clear_has_updatebegin();
  }
}

// optional .spark.UpdateReady updateready = 10;
inline bool Envelope::has_updateready() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Envelope::set_has_updateready() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Envelope::clear_has_updateready() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Envelope::clear_updateready() {
  if (updateready_ != NULL) updateready_->::spark::UpdateReady::Clear();
  clear_has_updateready();
}
inline const ::spark::UpdateReady& Envelope::updateready() const {
  return updateready_ != NULL ? *updateready_ : *default_instance_->updateready_;
}
inline ::spark::UpdateReady* Envelope::mutable_updateready() {
  set_has_updateready();
  if (updateready_ == NULL) updateready_ = new ::spark::UpdateReady;
  return updateready_;
}
inline ::spark::UpdateReady* Envelope::release_updateready() {
  clear_has_updateready();
  ::spark::UpdateReady* temp = updateready_;
  updateready_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_updateready(::spark::UpdateReady* updateready) {
  delete updateready_;
  updateready_ = updateready;
  if (updateready) {
    set_has_updateready();
  } else {
    clear_has_updateready();
  }
}

// optional .spark.Chunk chunk = 11;
inline bool Envelope::has_chunk() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Envelope::set_has_chunk() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Envelope::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Envelope::clear_chunk() {
  if (chunk_ != NULL) chunk_->::spark::Chunk::Clear();
  clear_has_chunk();
}
inline const ::spark::Chunk& Envelope::chunk() const {
  return chunk_ != NULL ? *chunk_ : *default_instance_->chunk_;
}
inline ::spark::Chunk* Envelope::mutable_chunk() {
  set_has_chunk();
  if (chunk_ == NULL) chunk_ = new ::spark::Chunk;
  return chunk_;
}
inline ::spark::Chunk* Envelope::release_chunk() {
  clear_has_chunk();
  ::spark::Chunk* temp = chunk_;
  chunk_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_chunk(::spark::Chunk* chunk) {
  delete chunk_;
  chunk_ = chunk;
  if (chunk) {
    set_has_chunk();
  } else {
    clear_has_chunk();
  }
}

// optional .spark.ChunkReceived chunkreceived = 12;
inline bool Envelope::has_chunkreceived() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Envelope::set_has_chunkreceived() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Envelope::clear_has_chunkreceived() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Envelope::clear_chunkreceived() {
  if (chunkreceived_ != NULL) chunkreceived_->::spark::ChunkReceived::Clear();
  clear_has_chunkreceived();
}
inline const ::spark::ChunkReceived& Envelope::chunkreceived() const {
  return chunkreceived_ != NULL ? *chunkreceived_ : *default_instance_->chunkreceived_;
}
inline ::spark::ChunkReceived* Envelope::mutable_chunkreceived() {
  set_has_chunkreceived();
  if (chunkreceived_ == NULL) chunkreceived_ = new ::spark::ChunkReceived;
  return chunkreceived_;
}
inline ::spark::ChunkReceived* Envelope::release_chunkreceived() {
  clear_has_chunkreceived();
  ::spark::ChunkReceived* temp = chunkreceived_;
  chunkreceived_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_chunkreceived(::spark::ChunkReceived* chunkreceived) {
  delete chunkreceived_;
  chunkreceived_ = chunkreceived;
  if (chunkreceived) {
    set_has_chunkreceived();
  } else {
    clear_has_chunkreceived();
  }
}

// optional .spark.UpdateDone updatedone = 13;
inline bool Envelope::has_updatedone() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Envelope::set_has_updatedone() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Envelope::clear_has_updatedone() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Envelope::clear_updatedone() {
  if (updatedone_ != NULL) updatedone_->::spark::UpdateDone::Clear();
  clear_has_updatedone();
}
inline const ::spark::UpdateDone& Envelope::updatedone() const {
  return updatedone_ != NULL ? *updatedone_ : *default_instance_->updatedone_;
}
inline ::spark::UpdateDone* Envelope::mutable_updatedone() {
  set_has_updatedone();
  if (updatedone_ == NULL) updatedone_ = new ::spark::UpdateDone;
  return updatedone_;
}
inline ::spark::UpdateDone* Envelope::release_updatedone() {
  clear_has_updatedone();
  ::spark::UpdateDone* temp = updatedone_;
  updatedone_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_updatedone(::spark::UpdateDone* updatedone) {
  delete updatedone_;
  updatedone_ = updatedone;
  if (updatedone) {
    set_has_updatedone();
  } else {
    clear_has_updatedone();
  }
}

// optional .spark.Hello hello = 14;
inline bool Envelope::has_hello() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Envelope::set_has_hello() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Envelope::clear_has_hello() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Envelope::clear_hello() {
  if (hello_ != NULL) hello_->::spark::Hello::Clear();
  clear_has_hello();
}
inline const ::spark::Hello& Envelope::hello() const {
  return hello_ != NULL ? *hello_ : *default_instance_->hello_;
}
inline ::spark::Hello* Envelope::mutable_hello() {
  set_has_hello();
  if (hello_ == NULL) hello_ = new ::spark::Hello;
  return hello_;
}
inline ::spark::Hello* Envelope::release_hello() {
  clear_has_hello();
  ::spark::Hello* temp = hello_;
  hello_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_hello(::spark::Hello* hello) {
  delete hello_;
  hello_ = hello;
  if (hello) {
    set_has_hello();
  } else {
    clear_has_hello();
  }
}

// optional .spark.KeyChange keychange = 15;
inline bool Envelope::has_keychange() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Envelope::set_has_keychange() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Envelope::clear_has_keychange() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Envelope::clear_keychange() {
  if (keychange_ != NULL) keychange_->::spark::KeyChange::Clear();
  clear_has_keychange();
}
inline const ::spark::KeyChange& Envelope::keychange() const {
  return keychange_ != NULL ? *keychange_ : *default_instance_->keychange_;
}
inline ::spark::KeyChange* Envelope::mutable_keychange() {
  set_has_keychange();
  if (keychange_ == NULL) keychange_ = new ::spark::KeyChange;
  return keychange_;
}
inline ::spark::KeyChange* Envelope::release_keychange() {
  clear_has_keychange();
  ::spark::KeyChange* temp = keychange_;
  keychange_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_keychange(::spark::KeyChange* keychange) {
  delete keychange_;
  keychange_ = keychange;
  if (keychange) {
    set_has_keychange();
  } else {
    clear_has_keychange();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace spark

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spark::DataType>() {
  return ::spark::DataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spark::Type>() {
  return ::spark::Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_spark_2eproto__INCLUDED
