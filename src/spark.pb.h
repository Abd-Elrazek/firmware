/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : Spark.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#ifndef _Spark_H
#define _Spark_H

#ifdef __cplusplus
  extern "C" {
#endif

#define MAX_BYTES_LENGTH 127
#define MAX_STRING_LENGTH 127
#define MAX_REPEATED_LENGTH 127

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);


/*******************************************************************
 * Enumeration: Spark.proto, line 7
 *******************************************************************/
enum DataType {
    _STRING = 1,
    _INT32 = 2,
    _DOUBLE = 3,
    _BOOL = 4,
    _BYTES = 5
};


/*******************************************************************
 * Enumeration: Spark.proto, line 75
 *******************************************************************/
enum Type {
    _CHUNK = 1,
    _CHUNKRECEIVED = 2,
    _EVENT = 3,
    _FUNCTIONCALL = 4,
    _FUNCTIONRETURN = 5,
    _HELLO = 6,
    _IGNORED = 7,
    _KEYCHANGE = 8,
    _UPDATEBEGIN = 9,
    _UPDATEDONE = 10,
    _UPDATEREADY = 11,
    _VARIABLEREQUEST = 12,
    _VARIABLEVALUE = 13
};



/*******************************************************************
 * Message: Spark.proto, line 15
 *******************************************************************/

/* Maximum size of a serialized DataValue-message, useful for buffer allocation. */
#define MAX_DataValue_SIZE 290

/* Structure that holds a deserialized DataValue-message. */
struct DataValue {
    enum DataType _type;
    int _vString_len;
    char _vString[MAX_STRING_LENGTH];
    signed long _vInt;
    double _vDouble;
    char _vBool;
    int _vBytes_len;
    char _vBytes[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int DataValue_write_delimited_to(struct DataValue *_DataValue, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int DataValue_write_with_tag(struct DataValue *_DataValue, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int DataValue_read_delimited_from(void *_buffer, struct DataValue *_DataValue, int offset);


/*******************************************************************
 * Message: Spark.proto, line 24
 *******************************************************************/

/* Maximum size of a serialized Chunk-message, useful for buffer allocation. */
#define MAX_Chunk_SIZE 269

/* Structure that holds a deserialized Chunk-message. */
struct Chunk {
    int _crc_len;
    char _crc[MAX_BYTES_LENGTH];
    unsigned long _length;
    int _data_len;
    char _data[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Chunk_write_delimited_to(struct Chunk *_Chunk, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Chunk_write_with_tag(struct Chunk *_Chunk, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Chunk_read_delimited_from(void *_buffer, struct Chunk *_Chunk, int offset);


/*******************************************************************
 * Message: Spark.proto, line 30
 *******************************************************************/

/* Maximum size of a serialized ChunkReceived-message, useful for buffer allocation. */
#define MAX_ChunkReceived_SIZE 132

/* Structure that holds a deserialized ChunkReceived-message. */
struct ChunkReceived {
    int _crc_len;
    char _crc[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ChunkReceived_write_delimited_to(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int ChunkReceived_write_with_tag(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int ChunkReceived_read_delimited_from(void *_buffer, struct ChunkReceived *_ChunkReceived, int offset);


/*******************************************************************
 * Message: Spark.proto, line 34
 *******************************************************************/

/* Maximum size of a serialized Event-message, useful for buffer allocation. */
#define MAX_Event_SIZE 262

/* Structure that holds a deserialized Event-message. */
struct Event {
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    int _data_len;
    char _data[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Event_write_delimited_to(struct Event *_Event, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Event_write_with_tag(struct Event *_Event, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Event_read_delimited_from(void *_buffer, struct Event *_Event, int offset);


/*******************************************************************
 * Message: Spark.proto, line 39
 *******************************************************************/

/* Maximum size of a serialized Ignored-message, useful for buffer allocation. */
#define MAX_Ignored_SIZE 9

/* Structure that holds a deserialized Ignored-message. */
struct Ignored {
    unsigned long _received;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Ignored_write_delimited_to(struct Ignored *_Ignored, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Ignored_write_with_tag(struct Ignored *_Ignored, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Ignored_read_delimited_from(void *_buffer, struct Ignored *_Ignored, int offset);


/*******************************************************************
 * Message: Spark.proto, line 43
 *******************************************************************/

/* Maximum size of a serialized KeyChange-message, useful for buffer allocation. */
#define MAX_KeyChange_SIZE 782

/* Structure that holds a deserialized KeyChange-message. */
struct KeyChange {
    int _ciphertext1_len;
    char _ciphertext1[MAX_BYTES_LENGTH];
    int _ciphertext2_len;
    char _ciphertext2[MAX_BYTES_LENGTH];
    int _ciphertext3_len;
    char _ciphertext3[MAX_BYTES_LENGTH];
    int _signature1_len;
    char _signature1[MAX_BYTES_LENGTH];
    int _signature2_len;
    char _signature2[MAX_BYTES_LENGTH];
    int _signature3_len;
    char _signature3[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int KeyChange_write_delimited_to(struct KeyChange *_KeyChange, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int KeyChange_write_with_tag(struct KeyChange *_KeyChange, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int KeyChange_read_delimited_from(void *_buffer, struct KeyChange *_KeyChange, int offset);


/*******************************************************************
 * Message: Spark.proto, line 53
 *******************************************************************/

/* Maximum size of a serialized VariableRequest-message, useful for buffer allocation. */
#define MAX_VariableRequest_SIZE 36965

/* Structure that holds a deserialized VariableRequest-message. */
struct VariableRequest {
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    char _set;
    int _value_repeated_len;
    struct DataValue _value[MAX_REPEATED_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int VariableRequest_write_delimited_to(struct VariableRequest *_VariableRequest, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int VariableRequest_write_with_tag(struct VariableRequest *_VariableRequest, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int VariableRequest_read_delimited_from(void *_buffer, struct VariableRequest *_VariableRequest, int offset);


/*******************************************************************
 * Message: Spark.proto, line 59
 *******************************************************************/

/* Maximum size of a serialized VariableValue-message, useful for buffer allocation. */
#define MAX_VariableValue_SIZE 36962

/* Structure that holds a deserialized VariableValue-message. */
struct VariableValue {
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    int _value_repeated_len;
    struct DataValue _value[MAX_REPEATED_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int VariableValue_write_delimited_to(struct VariableValue *_VariableValue, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int VariableValue_write_with_tag(struct VariableValue *_VariableValue, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int VariableValue_read_delimited_from(void *_buffer, struct VariableValue *_VariableValue, int offset);


/*******************************************************************
 * Message: Spark.proto, line 64
 *******************************************************************/

/* Maximum size of a serialized FunctionCall-message, useful for buffer allocation. */
#define MAX_FunctionCall_SIZE 53472

/* Structure that holds a deserialized FunctionCall-message. */
struct FunctionCall {
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    int _argNames_repeated_len;
    int _argNames_len[MAX_REPEATED_LENGTH];
    char _argNames[MAX_REPEATED_LENGTH][MAX_STRING_LENGTH];
    int _value_repeated_len;
    struct DataValue _value[MAX_REPEATED_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int FunctionCall_write_delimited_to(struct FunctionCall *_FunctionCall, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int FunctionCall_write_with_tag(struct FunctionCall *_FunctionCall, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int FunctionCall_read_delimited_from(void *_buffer, struct FunctionCall *_FunctionCall, int offset);


/*******************************************************************
 * Message: Spark.proto, line 70
 *******************************************************************/

/* Maximum size of a serialized FunctionReturn-message, useful for buffer allocation. */
#define MAX_FunctionReturn_SIZE 36962

/* Structure that holds a deserialized FunctionReturn-message. */
struct FunctionReturn {
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    int _value_repeated_len;
    struct DataValue _value[MAX_REPEATED_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int FunctionReturn_write_delimited_to(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int FunctionReturn_write_with_tag(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int FunctionReturn_read_delimited_from(void *_buffer, struct FunctionReturn *_FunctionReturn, int offset);


/*******************************************************************
 * Message: Spark.proto, line 91
 *******************************************************************/

/* Maximum size of a serialized Envelope-message, useful for buffer allocation. */
#define MAX_Envelope_SIZE 165827

/* Structure that holds a deserialized Envelope-message. */
struct Envelope {
    unsigned long _counter;
    enum Type _type;
    struct VariableRequest _variablerequest;
    struct VariableValue _variablevalue;
    struct FunctionCall _functioncall;
    struct FunctionReturn _functionreturn;
    struct Event _event;
    struct Ignored _ignored;
    struct Chunk _chunk;
    struct ChunkReceived _chunkreceived;
    struct KeyChange _keychange;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Envelope_write_delimited_to(struct Envelope *_Envelope, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Envelope_write_with_tag(struct Envelope *_Envelope, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Envelope_read_delimited_from(void *_buffer, struct Envelope *_Envelope, int offset);



#ifdef __cplusplus
  }
#endif

#endif

